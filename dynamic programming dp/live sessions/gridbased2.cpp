// NUmber of non empty disctint subsquences in a string.  ==> CLASSICAL AND NON-TRIVIAL PROBLEM. REMEMBER THIS CODE.

#include <bits/stdc++.h>
using namespace std;

void solve()
{                       //doing this iterative dp way. recursivly will be bit more complex
    int n;
    cin >> n;
    string s;
    cin >> s;
    int dp[n + 1];   // new subsequenes generated by appending the ith character that havent been formed yet in the prefix of string
    int psum[n + 1]; // total number of new char generated now.

    int last[26];
    memset(last, -1, sizeof(last));

    dp[0] = 1;
    psum[0] = 1; // initialized for the empty array at 0 index

    for (int i = 1; i <= n; i++)
    {
        if (last[s[i - 1] - 'a'] == -1)
        {                        // the last string is zero indexed and dp is one indexed, so we have to take care of level. ith position in dp will refer to i-1 for string
            dp[i] = psum[i - 1]; // when element is not found in before then we just set dp[i] as prefix sum of last one
        }
        else
        {
            dp[i] = psum[i - 1] - psum[last[s[i - 1] - 'a']]; // this is the case when the element is found earlier so we substract the last occurance prefix sum that will give me the number the new distinct subsequences formed.
        }
        psum[i] = psum[i - 1] + dp[i];

        last[s[i - 1] - 'a'] = (i - 1); // last array hame bataega ki koi character last baar kab present that. vo index us last array me save kar rhe ham
    }
    cout << psum[n] - 1 << endl; // substracting the empty substring (the first one which we made by ourself) as non empty disctint subsquences are asked
}
signed main()
{
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);

    // int _t; cin>>_t;while(_t--)
    solve();
}